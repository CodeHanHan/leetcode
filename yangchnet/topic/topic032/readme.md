# 最长有效括号

## 1. 题目描述
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

## 2. 示例
示例1
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

示例2
```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

示例3
```
输入：s = ""
输出：0
```

**提示**
- 0 <= s.length <= $3 * 10^4$
- s[i] 为 '(' 或 ')'

## 3. 解题

1. 栈
始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

- 对于遇到的每个 `(` ，我们将它的下标放入栈中
- 对于遇到的每个 `)` ，我们先弹出栈顶元素表示匹配了当前右括号：
    - 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
    - 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」

2. 动态规划

我们定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0 。显然有效的子串一定以 `)` 结尾，因此我们可以知道以 `(` 结尾的子串对应的 dp 值必定为 0 ，我们只需要求解 `)` 在 dp 数组中对应位置的值。

我们从前往后遍历字符串求解 \textit{dp}dp 值，我们每两个字符检查一次：

- `s[i]=')'` 且 `s[i−1]='('`，也就是字符串形如 '......()`，我们可以推出：
```go
dp[i]=dp[i−2]+2
```
我们可以进行这样的转移，是因为结束部分的 "()" 是一个有效子字符串，并且将之前有效子字符串的长度增加了 2 。

- `s[i]=')'` 且 `s[i−1]=')'`，也就是字符串形如`......))`，我们可以推出：
如果 s[i−dp[i−1]−1]=‘(’，那么
```go
dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2
```